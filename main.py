"""
AnalyticalBlackLight
Made by perpetualCreations

Uses pytrends as a black light on student cheating during virtual testing.
This serves as a tool to increase the number of keywords that can be analyzed at the same time.
Additionally can generate a plot of search interest, or return as a pandas dataframe for further data science processing.

List of keywords must be a multiple of 5.
TODO implement argparse
"""

from pytrends.request import TrendReq
from random import randint
import pandas, configparser
import argparse

targets_parser = configparser.ConfigParser()
targets_parser.read("targets.cfg")
target_date_1 = targets_parser["TIME"]["date_1"]
target_date_2 = targets_parser["TIME"]["date_2"]
target_country = targets_parser["LOCATION"]["country"]
target_state = targets_parser["LOCATION"]["state"]
target_county = targets_parser["LOCATION"]["county"]

pytrend = TrendReq()

collection_list = [] # dataframes generated by collect() are appended to this list.
export_dataframe = None # future dataframe overwritten by merging
collect_cycle = 0 # collection cycles elapsed.

def keywords_read():
    """
    Reads keywords.
    :return: list of keywords.
    """
    with open("keywords.txt") as keywords:
        return keywords.read().splitlines()
    pass
pass

print("Targets: \nFirst Date: " + target_date_1 + "\nSecond Date: " + target_date_2 + "\nCountry: " + target_country +
      "\nState: " + target_state + "\nCounty Code: " + target_county + "\n")
print("Loaded keywords: ")
print(keywords_read())

while collect_cycle != len(keywords_read()):
    pytrend.build_payload(
        [keywords_read()[collect_cycle], keywords_read()[collect_cycle + 1], keywords_read()[collect_cycle + 2],
         keywords_read()[collect_cycle + 3], keywords_read()[collect_cycle + 4]],
        timeframe=target_date_1 + " " + target_date_2,
        geo=target_country + "-" + target_state + "-" + target_county)
    collection_list.append(pytrend.interest_over_time())
    collect_cycle += 5
pass

def merge():
    """
    Merges all dataframe objects.
    :return:
    """
    global export_dataframe
    export_dataframe = collection_list[0]
    collection_list_index = len(collection_list) - 1
    while collection_list_index != 0:
        print("export dataframe before merge")
        print(export_dataframe)
        pandas.merge(export_dataframe, collection_list[collection_list_index], how = "outer")
        collection_list_index -= 1
        print("current to be merged")
        print(collection_list[collection_list_index])
        print("current overall")
        print(export_dataframe)
    pass
    print(export_dataframe)
pass

def export():
    """
    Exports data to CSV. TODO file path -> argparse
    :return:
    """
    export_dataframe.to_csv((input("Export Path: ") + str(randint(1, 9999999)) + ".csv"))
pass

def graph():
    """
    Matplotlib graphing from CSV data.
    :return:
    """

pass

export_dataframe = pandas.concat(collection_list, axis = 1)
export_dataframe.to_csv("name.csv")
# merge()
# export()
